import type { FastifyPluginAsync } from 'fastify';
import { Prisma } from '@prisma/client';
import { generatePythonExport, generatePythonCode } from '../lib/python-export.js';
import { writeWorkflowFiles, commitAndPush } from '../lib/github.js';
import { create as createTar } from 'tar';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import type { WorkflowCreateInput, WorkflowUpdateInput } from '@twiddle/shared';
import { prisma } from '../lib/prisma.js';

/**
 * Helper to commit workflow to GitHub if configured
 */
async function commitWorkflowToGitHub(
  workflow: {
    id: string;
    name: string;
    description: string | null;
    githubRepo: string | null;
    githubBranch: string | null;
    githubPath: string | null;
    localPath: string | null;
    githubCredentialId: string | null;
    pythonWorkflow: string | null;
    pythonActivities: string | null;
    pythonRequirements: string | null;
  },
): Promise<{ success: boolean; commitSha?: string; error?: string }> {
  if (!workflow.githubRepo || !workflow.localPath || !workflow.githubCredentialId) {
    return { success: true }; // Not configured, skip
  }

  // Get credentials
  const credential = await prisma.credential.findUnique({
    where: { id: workflow.githubCredentialId },
  });

  if (!credential || credential.type !== 'github') {
    return { success: false, error: 'GitHub credential not found' };
  }

  // Prepare files
  const files: Record<string, string> = {
    'workflow.py': workflow.pythonWorkflow || '',
    'activities.py': workflow.pythonActivities || '',
    'requirements.txt': workflow.pythonRequirements || '',
    'README.md': `# ${workflow.name}\n\n${workflow.description || 'A Twiddle workflow.'}\n\nGenerated by Twiddle.`,
  };

  // Write files to local repo
  const workflowPath = workflow.githubPath || '';
  await writeWorkflowFiles(workflow.localPath, workflowPath, files);

  // Commit and push
  const commitMessage = `Update workflow: ${workflow.name}`;
  const result = await commitAndPush(
    workflow.localPath,
    commitMessage,
    workflow.githubBranch || 'main',
  );

  if (result.success && result.commitSha) {
    // Update last commit SHA
    await prisma.workflow.update({
      where: { id: workflow.id },
      data: { lastCommitSha: result.commitSha },
    });
  }

  return result;
}

export const workflowRoutes: FastifyPluginAsync = async (app) => {
  // List all workflows (filtered by group membership if authenticated)
  app.get<{
    Querystring: { groupId?: string };
  }>('/', async (request, _reply) => {
    const userId = (request as { user?: { id: string } }).user?.id;
    const { groupId } = request.query;

    // Build where clause based on authentication and group filter
    let whereClause: Prisma.WorkflowWhereInput = {};

    if (groupId) {
      // Filter by specific group
      whereClause.groupId = groupId;
    } else if (userId) {
      // Get user's group IDs
      const memberships = await prisma.groupMember.findMany({
        where: { userId },
        select: { groupId: true },
      });
      const userGroupIds = memberships.map((m: typeof memberships[number]) => m.groupId);

      // Show workflows in user's groups OR created by user OR with no group
      whereClause = {
        OR: [
          { groupId: { in: userGroupIds } },
          { createdById: userId },
          { groupId: null },
        ],
      };
    }
    // If not authenticated, show all workflows (for development)

    const workflows = await prisma.workflow.findMany({
      where: whereClause,
      orderBy: { updatedAt: 'desc' },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });
    return workflows;
  });

  // Get a single workflow with locking logic
  app.get<{ Params: { id: string } }>('/:id', async (request, reply) => {
    const { id } = request.params;
    const user = (request as { user?: { id: string; name?: string; email: string } }).user;

    // 1. Fetch workflow with current lock
    let workflow = await prisma.workflow.findUnique({
      where: { id },
      include: {
        lock: {
          include: { user: true },
        },
      },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // 2. Handle Lock Logic
    let lockedByObject = null;
    const now = new Date();
    const LOCK_TIMEOUT = 2 * 60 * 1000; // 2 minutes

    // Check for stale lock
    if (workflow.lock) {
      if (now.getTime() - new Date(workflow.lock.updatedAt).getTime() > LOCK_TIMEOUT) {
        // Stale lock - delete it
        try {
          await prisma.workflowLock.delete({ where: { id: workflow.lock.id } });
          workflow.lock = null; // Clear from memory object
        } catch (e) {
          // Ignore delete errors (race condition)
        }
      } else if (workflow.lock.requestingAt) {
        // Check for request timeout (1 minute)
        const REQUEST_TIMEOUT = 1 * 60 * 1000;
        if (now.getTime() - new Date(workflow.lock.requestingAt).getTime() > REQUEST_TIMEOUT) {
          // Forced Swap
          try {
            await prisma.workflowLock.update({
              where: { id: workflow.lock.id },
              data: {
                userId: workflow.lock.requestingUserId!,
                requestingUserId: null,
                requestingAt: null,
                updatedAt: new Date()
              }
            });
            // Update memory object for response
            workflow.lock.userId = workflow.lock.requestingUserId!;
            workflow.lock.requestingUserId = null;
          } catch (e) {
            // Race condition
          }
        }
      }
    }

    if (workflow.lock) {
      // Logic for existing lock
      if (user && workflow.lock.userId === user.id) {
        // Locked by current user - refresh heartbeat
        try {
          await prisma.workflowLock.update({
            where: { id: workflow.lock.id },
            data: { updatedAt: new Date() },
          });
          lockedByObject = { id: user.id, name: user.name || user.email, email: user.email, isMe: true };
        } catch (e) {
          // Lock might have been deleted by race condition, treat as lost
          lockedByObject = null;
        }
      } else {
        // Locked by someone else
        lockedByObject = {
          id: workflow.lock.userId,
          name: workflow.lock.user.name || workflow.lock.user.email,
          email: workflow.lock.user.email,
          isMe: false,
        };
      }
    }

    if (lockedByObject) {
      // Add request info if present
      if (workflow.lock?.requestingUserId) {
        const requestingUser = await prisma.user.findUnique({ where: { id: workflow.lock.requestingUserId } });
        if (requestingUser) {
          (lockedByObject as any).request = {
            userId: requestingUser.id,
            name: requestingUser.name || requestingUser.email,
            email: requestingUser.email,
            requestedAt: workflow.lock.requestingAt
          };
        }
      }
    }

    // if still unlocked and user is present, acquire lock
    if (!workflow.lock && !lockedByObject && user) {
      try {
        const newLock = await prisma.workflowLock.create({
          data: {
            workflowId: id,
            userId: user.id,
          },
          include: { user: true },
        });
        lockedByObject = { id: user.id, name: user.name || user.email, email: user.email, isMe: true };
      } catch (e) {
        // Race condition - someone else locked it
        const raceLock = await prisma.workflowLock.findUnique({ where: { workflowId: id }, include: { user: true } });
        if (raceLock) {
          lockedByObject = {
            id: raceLock.userId,
            name: raceLock.user.name || raceLock.user.email,
            email: raceLock.user.email,
            isMe: false
          };
        }
      }
    }

    return { ...workflow, lockedBy: lockedByObject };
  });

  // Heartbeat - refresh lock & check requests
  app.post<{ Params: { id: string } }>('/:id/lock', async (request, reply) => {
    const { id } = request.params;
    const user = (request as { user?: { id: string } }).user;

    if (!user) {
      return reply.status(401).send({ error: 'Unauthorized' });
    }

    const lock = await prisma.workflowLock.findUnique({ where: { workflowId: id } });
    if (!lock) {
      // Try to acquire
      try {
        await prisma.workflowLock.create({
          data: { workflowId: id, userId: user.id }
        });
        return { success: true, status: 'acquired' };
      } catch (e) {
        return reply.status(409).send({ error: 'Workflow is locked by another user' });
      }
    }

    if (lock.userId !== user.id) {
      // Check if stale
      const now = new Date();
      const LOCK_TIMEOUT = 2 * 60 * 1000;
      if (now.getTime() - new Date(lock.updatedAt).getTime() > LOCK_TIMEOUT) {
        // Takeover
        await prisma.workflowLock.delete({ where: { id: lock.id } });
        await prisma.workflowLock.create({
          data: { workflowId: id, userId: user.id }
        });
        return { success: true, status: 'taken_over' };
      }
      return reply.status(409).send({ error: 'Workflow is locked by another user' });
    }

    // Refresh
    const updatedLock = await prisma.workflowLock.update({
      where: { id: lock.id },
      data: { updatedAt: new Date() },
      include: { requestingUser: true }
    });

    // Check for active request
    let requestInfo = null;
    if (updatedLock.requestingUserId) {
      requestInfo = {
        userId: updatedLock.requestingUserId,
        name: updatedLock.requestingUser?.name || updatedLock.requestingUser?.email,
        email: updatedLock.requestingUser?.email,
        requestedAt: updatedLock.requestingAt
      };
    }

    return { success: true, status: 'refreshed', request: requestInfo };
  });

  // Request Lock Takeover
  app.post<{ Params: { id: string } }>('/:id/lock/request', async (request, reply) => {
    const { id } = request.params;
    const user = (request as { user?: { id: string } }).user;
    if (!user) return reply.status(401).send({ error: 'Unauthorized' });

    const lock = await prisma.workflowLock.findUnique({ where: { workflowId: id } });
    if (!lock) return { success: true, status: 'acquired' }; // Logic elsewhere will acquire it on next load, but this signals 'go ahead'

    if (lock.userId === user.id) return { success: true, status: 'already_locked' };

    await prisma.workflowLock.update({
      where: { id: lock.id },
      data: { requestingUserId: user.id, requestingAt: new Date() }
    });
    return { success: true, status: 'requested' };
  });

  // Resolve Lock Request (Accept/Deny)
  app.post<{ Params: { id: string }, Body: { action: 'ACCEPT' | 'DENY' } }>('/:id/lock/resolve', async (request, reply) => {
    const { id } = request.params;
    const { action } = request.body;
    const user = (request as { user?: { id: string } }).user;
    if (!user) return reply.status(401).send({ error: 'Unauthorized' });

    const lock = await prisma.workflowLock.findUnique({ where: { workflowId: id } });
    if (!lock || lock.userId !== user.id) return reply.status(400).send({ error: 'Invalid lock state' });

    if (action === 'ACCEPT' && lock.requestingUserId) {
      await prisma.workflowLock.update({
        where: { id: lock.id },
        data: {
          userId: lock.requestingUserId,
          requestingUserId: null,
          requestingAt: null,
          updatedAt: new Date()
        }
      });
      return { success: true, status: 'swapped' };
    } else {
      // Deny or no request
      await prisma.workflowLock.update({
        where: { id: lock.id },
        data: { requestingUserId: null, requestingAt: null }
      });
      return { success: true, status: 'denied' };
    }
  });

  // Unlock - release lock
  app.post<{ Params: { id: string } }>('/:id/unlock', async (request, reply) => {
    const { id } = request.params;
    const user = (request as { user?: { id: string } }).user;

    if (!user) return reply.status(401).send({ error: 'Unauthorized' });

    // Only delete if owned by user
    const lock = await prisma.workflowLock.findUnique({ where: { workflowId: id } });
    if (lock && lock.userId === user.id) {
      await prisma.workflowLock.delete({ where: { id: lock.id } });
    }
    return { success: true };
  });


  // Create a new workflow
  app.post<{ Body: WorkflowCreateInput & { groupId?: string; folderId?: string } }>('/', async (request, reply) => {
    const { name, description, nodes, connections, settings, tags, groupId, folderId } = request.body;
    const userId = (request as { user?: { id: string } }).user?.id;

    // Generate Python code from workflow definition
    const workflowNodes = (nodes || []) as unknown[];
    const workflowConnections = (connections || []) as unknown[];

    const pythonCode = generatePythonCode({
      id: 'new',
      name: name || 'Untitled Workflow',
      description: description || undefined,
      nodes: workflowNodes,
      connections: workflowConnections,
    } as Parameters<typeof generatePythonCode>[0]);

    const workflow = await prisma.workflow.create({
      data: {
        name,
        description,
        nodes: (nodes || []) as unknown as Prisma.InputJsonValue,
        connections: (connections || []) as unknown as Prisma.InputJsonValue,
        settings: (settings || {}) as unknown as Prisma.InputJsonValue,
        tags: tags || [],
        createdById: userId,
        groupId,
        folderId,
        // Store generated Python code
        pythonWorkflow: pythonCode.pythonWorkflow,
        pythonActivities: pythonCode.pythonActivities,
        pythonRequirements: pythonCode.pythonRequirements,
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
        folder: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return reply.status(201).send(workflow);
  });

  // Update a workflow
  app.put<{ Params: { id: string }; Body: WorkflowUpdateInput }>(
    '/:id',
    async (request, _reply) => {
      const { id } = request.params;
      const { name, description, nodes, connections, settings, active, tags } = request.body;

      // Get existing workflow to merge with updates
      const existing = await prisma.workflow.findUnique({ where: { id } });
      if (!existing) {
        throw new Error('Workflow not found');
      }

      // Regenerate Python code if nodes or connections changed
      let pythonCodeUpdate = {};
      if (nodes !== undefined || connections !== undefined || name !== undefined) {
        const workflowNodes = (nodes ?? existing.nodes) as unknown[];
        const workflowConnections = (connections ?? existing.connections) as unknown[];

        const pythonCode = generatePythonCode({
          id,
          name: name ?? existing.name,
          description: (description ?? existing.description) || undefined,
          nodes: workflowNodes,
          connections: workflowConnections,
        } as Parameters<typeof generatePythonCode>[0]);

        pythonCodeUpdate = {
          pythonWorkflow: pythonCode.pythonWorkflow,
          pythonActivities: pythonCode.pythonActivities,
          pythonRequirements: pythonCode.pythonRequirements,
        };
      }

      const workflow = await prisma.workflow.update({
        where: { id },
        data: {
          // Increment version on every save
          version: { increment: 1 },
          ...(name !== undefined && { name }),
          ...(description !== undefined && { description }),
          ...(nodes !== undefined && { nodes: nodes as unknown as Prisma.InputJsonValue }),
          ...(connections !== undefined && { connections: connections as unknown as Prisma.InputJsonValue }),
          ...(settings !== undefined && { settings: settings as unknown as Prisma.InputJsonValue }),
          ...(active !== undefined && { active }),
          ...(tags !== undefined && { tags }),
          ...pythonCodeUpdate,
        },
      });

      // Create a version snapshot
      const userId = (request as { user?: { id: string } }).user?.id;
      await prisma.workflowVersion.create({
        data: {
          workflowId: id,
          version: workflow.version,
          nodes: workflow.nodes,
          connections: workflow.connections,
          settings: workflow.settings,
          createdById: userId
        }
      });

      // Commit to GitHub if configured
      if (workflow.githubRepo && workflow.localPath) {
        const gitResult = await commitWorkflowToGitHub(workflow);
        if (!gitResult.success) {
          request.log.error({ error: gitResult.error }, 'GitHub commit failed');
          // Don't fail the save, just log the error
        }
      }

      return workflow;
    },
  );

  // Delete a workflow
  app.delete<{ Params: { id: string } }>('/:id', async (request, reply) => {
    const { id } = request.params;

    await prisma.workflow.delete({
      where: { id },
    });

    return reply.status(204).send();
  });

  // Promote workflow to next environment
  // DV -> UT -> LT -> PD
  // Only admins can promote to PD
  app.post<{
    Params: { id: string };
    Body: { targetEnvironment: 'UT' | 'LT' | 'PD' };
  }>('/:id/promote', async (request, reply) => {
    const { id } = request.params;
    const { targetEnvironment } = request.body;
    const user = (request as { user?: { id: string; isAdmin?: boolean } }).user;

    // Get current workflow
    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Define valid promotion paths
    const promotionOrder = ['DV', 'UT', 'LT', 'PD'] as const;
    const currentIndex = promotionOrder.indexOf(workflow.environment);
    const targetIndex = promotionOrder.indexOf(targetEnvironment);

    // Validate promotion is sequential (can only promote to next stage)
    if (targetIndex !== currentIndex + 1) {
      return reply.status(400).send({
        error: `Invalid promotion. Can only promote from ${workflow.environment} to ${promotionOrder[currentIndex + 1] || 'nowhere (already at PD)'}`
      });
    }

    // Direct usage of this endpoint is now restricted to Admins (Force Promote)
    // Regular users must use the /promotions/request flow.
    if (!user?.isAdmin) {
      return reply.status(403).send({
        error: 'Direct promotion is restricted to administrators. Please use the Promotion Request workflow.'
      });
    }

    // Perform the promotion
    const updatedWorkflow = await prisma.workflow.update({
      where: { id },
      data: {
        environment: targetEnvironment,
        promotedAt: new Date(),
        promotedById: user?.id,
      },
      include: {
        group: {
          select: { id: true, name: true },
        },
        createdBy: {
          select: { id: true, email: true, name: true },
        },
      },
    });

    return updatedWorkflow;
  });

  // Demote workflow to previous environment (admin only)
  app.post<{
    Params: { id: string };
    Body: { targetEnvironment: 'DV' | 'UT' | 'LT' };
  }>('/:id/demote', async (request, reply) => {
    const { id } = request.params;
    const { targetEnvironment } = request.body;
    const user = (request as { user?: { id: string; isAdmin?: boolean } }).user;

    // Only admins can demote
    if (!user?.isAdmin) {
      return reply.status(403).send({
        error: 'Only administrators can demote workflows'
      });
    }

    // Get current workflow
    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Define valid demotion paths
    const promotionOrder = ['DV', 'UT', 'LT', 'PD'] as const;
    const currentIndex = promotionOrder.indexOf(workflow.environment);
    const targetIndex = promotionOrder.indexOf(targetEnvironment);

    // Validate demotion is to a lower stage
    if (targetIndex >= currentIndex) {
      return reply.status(400).send({
        error: `Invalid demotion. Target environment must be lower than current (${workflow.environment})`
      });
    }

    // Perform the demotion
    const updatedWorkflow = await prisma.workflow.update({
      where: { id },
      data: {
        environment: targetEnvironment,
        promotedAt: new Date(),
        promotedById: user?.id,
      },
      include: {
        group: {
          select: { id: true, name: true },
        },
        createdBy: {
          select: { id: true, email: true, name: true },
        },
      },
    });

    return updatedWorkflow;
  });

  // Export workflow as Python Temporal application
  app.get<{
    Params: { id: string };
    Querystring: { format?: 'json' | 'tar' };
  }>('/:id/export/python', async (request, reply) => {
    const { id } = request.params;
    const { format = 'tar' } = request.query;

    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Generate Python files
    const files = generatePythonExport({
      id: workflow.id,
      name: workflow.name,
      description: workflow.description || undefined,
      nodes: workflow.nodes as unknown[],
      connections: workflow.connections as unknown[],
    } as Parameters<typeof generatePythonExport>[0]);

    // Create directory name from workflow name, environment, and version
    const safeName = workflow.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '') || 'workflow';
    const dirName = `${safeName}-${workflow.environment.toLowerCase()}-v${workflow.version}`;

    if (format === 'tar') {
      // Create a temporary directory with the workflow files
      const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'twiddle-export-'));
      const workflowDir = path.join(tempDir, dirName);

      try {
        // Create the workflow directory
        fs.mkdirSync(workflowDir, { recursive: true });

        // Write all files to the directory
        for (const [filename, content] of Object.entries(files)) {
          fs.writeFileSync(path.join(workflowDir, filename), content, 'utf-8');
        }

        // Also write the workflow definition for re-import
        const definition = {
          workflowId: workflow.id,
          workflowName: workflow.name,
          workflowDescription: workflow.description,
          version: workflow.version,
          environment: workflow.environment,
          exportedAt: new Date().toISOString(),
          definition: {
            nodes: workflow.nodes,
            connections: workflow.connections,
            settings: workflow.settings,
            tags: workflow.tags,
          },
        };
        fs.writeFileSync(
          path.join(workflowDir, 'twiddle-workflow.json'),
          JSON.stringify(definition, null, 2),
          'utf-8'
        );

        // Create the tarball
        const tarballPath = path.join(tempDir, `${dirName}.tar.gz`);
        await createTar(
          {
            gzip: true,
            file: tarballPath,
            cwd: tempDir,
          },
          [dirName]
        );

        // Read the tarball and send it
        const tarballBuffer = fs.readFileSync(tarballPath);

        // Clean up temp directory
        fs.rmSync(tempDir, { recursive: true, force: true });

        // Send the tarball
        return reply
          .header('Content-Type', 'application/gzip')
          .header('Content-Disposition', `attachment; filename="${dirName}.tar.gz"`)
          .send(tarballBuffer);

      } catch (err) {
        // Clean up on error
        try {
          fs.rmSync(tempDir, { recursive: true, force: true });
        } catch {
          // Ignore cleanup errors
        }
        throw err;
      }
    }

    // Return as JSON with file contents and workflow definition for re-import
    return {
      workflowId: workflow.id,
      workflowName: workflow.name,
      workflowDescription: workflow.description,
      version: workflow.version,
      environment: workflow.environment,
      exportedAt: new Date().toISOString(),
      directoryName: dirName,
      // Include workflow definition for import
      definition: {
        nodes: workflow.nodes,
        connections: workflow.connections,
        settings: workflow.settings,
        tags: workflow.tags,
      },
      files,
    };
  });

  // Get all versions for a workflow
  app.get<{ Params: { id: string } }>('/:id/versions', async (request, reply) => {
    const { id } = request.params;

    const versions = await prisma.workflowVersion.findMany({
      where: { workflowId: id },
      orderBy: { version: 'desc' },
      select: {
        id: true,
        version: true,
        createdAt: true,
        createdBy: {
          select: { id: true, name: true, email: true }
        }
      }
    });
    return versions;
  });

  // Get a specific version
  app.get<{ Params: { id: string, versionId: string } }>('/:id/versions/:versionId', async (request, reply) => {
    const { id, versionId } = request.params;

    const version = await prisma.workflowVersion.findUnique({
      where: { id: versionId }
    });

    if (!version || version.workflowId !== id) {
      return reply.status(404).send({ error: 'Version not found' });
    }

    return version;
  });

  // Import workflow from exported JSON
  app.post<{
    Body: {
      workflowName?: string;
      workflowDescription?: string;
      definition: {
        nodes: unknown[];
        connections: unknown[];
        settings?: unknown;
        tags?: string[];
      };
      groupId?: string;
    };
  }>('/import', async (request, reply) => {
    const { workflowName, workflowDescription, definition, groupId } = request.body;
    const userId = (request as { user?: { id: string } }).user?.id;

    if (!definition || !definition.nodes) {
      return reply.status(400).send({ error: 'Invalid import data: missing definition.nodes' });
    }

    const name = workflowName || 'Imported Workflow';
    const nodes = definition.nodes || [];
    const connections = definition.connections || [];

    // Generate Python code from imported workflow
    const pythonCode = generatePythonCode({
      id: 'imported',
      name,
      description: workflowDescription || undefined,
      nodes: nodes as unknown[],
      connections: connections as unknown[],
    } as Parameters<typeof generatePythonCode>[0]);

    const workflow = await prisma.workflow.create({
      data: {
        name,
        description: workflowDescription,
        nodes: nodes as unknown as Prisma.InputJsonValue,
        connections: connections as unknown as Prisma.InputJsonValue,
        settings: (definition.settings || {}) as unknown as Prisma.InputJsonValue,
        tags: definition.tags || [],
        createdById: userId,
        groupId,
        pythonWorkflow: pythonCode.pythonWorkflow,
        pythonActivities: pythonCode.pythonActivities,
        pythonRequirements: pythonCode.pythonRequirements,
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return reply.status(201).send(workflow);
  });
};
