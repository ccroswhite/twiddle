import type { FastifyPluginAsync } from 'fastify';
import { Prisma } from '@prisma/client';
import { generatePythonExport, generatePythonCode } from '../lib/python-export.js';
import { writeWorkflowFiles, commitAndPush } from '../lib/github.js';
import { create as createTar } from 'tar';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import type { WorkflowCreateInput, WorkflowUpdateInput } from '@twiddle/shared';
import { prisma } from '../lib/prisma.js';

/**
 * Helper to commit workflow to GitHub if configured
 */
async function commitWorkflowToGitHub(
  workflow: {
    id: string;
    name: string;
    description: string | null;
    githubRepo: string | null;
    githubBranch: string | null;
    githubPath: string | null;
    localPath: string | null;
    githubCredentialId: string | null;
    pythonWorkflow: string | null;
    pythonActivities: string | null;
    pythonRequirements: string | null;
  },
): Promise<{ success: boolean; commitSha?: string; error?: string }> {
  if (!workflow.githubRepo || !workflow.localPath || !workflow.githubCredentialId) {
    return { success: true }; // Not configured, skip
  }

  // Get credentials
  const credential = await prisma.credential.findUnique({
    where: { id: workflow.githubCredentialId },
  });

  if (!credential || credential.type !== 'github') {
    return { success: false, error: 'GitHub credential not found' };
  }

  // Prepare files
  const files: Record<string, string> = {
    'workflow.py': workflow.pythonWorkflow || '',
    'activities.py': workflow.pythonActivities || '',
    'requirements.txt': workflow.pythonRequirements || '',
    'README.md': `# ${workflow.name}\n\n${workflow.description || 'A Twiddle workflow.'}\n\nGenerated by Twiddle.`,
  };

  // Write files to local repo
  const workflowPath = workflow.githubPath || '';
  await writeWorkflowFiles(workflow.localPath, workflowPath, files);

  // Commit and push
  const commitMessage = `Update workflow: ${workflow.name}`;
  const result = await commitAndPush(
    workflow.localPath,
    commitMessage,
    workflow.githubBranch || 'main',
  );

  if (result.success && result.commitSha) {
    // Update last commit SHA
    await prisma.workflow.update({
      where: { id: workflow.id },
      data: { lastCommitSha: result.commitSha },
    });
  }

  return result;
}

export const workflowRoutes: FastifyPluginAsync = async (app) => {
  // List all workflows (filtered by group membership if authenticated)
  app.get<{
    Querystring: { groupId?: string };
  }>('/', async (request, _reply) => {
    const userId = (request as { user?: { id: string } }).user?.id;
    const { groupId } = request.query;

    // Build where clause based on authentication and group filter
    let whereClause: Prisma.WorkflowWhereInput = {};

    if (groupId) {
      // Filter by specific group
      whereClause.groupId = groupId;
    } else if (userId) {
      // Get user's group IDs
      const memberships = await prisma.groupMember.findMany({
        where: { userId },
        select: { groupId: true },
      });
      const userGroupIds = memberships.map((m: typeof memberships[number]) => m.groupId);

      // Show workflows in user's groups OR created by user OR with no group
      whereClause = {
        OR: [
          { groupId: { in: userGroupIds } },
          { createdById: userId },
          { groupId: null },
        ],
      };
    }
    // If not authenticated, show all workflows (for development)

    const workflows = await prisma.workflow.findMany({
      where: whereClause,
      orderBy: { updatedAt: 'desc' },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });
    return workflows;
  });

  // Get a single workflow
  app.get<{ Params: { id: string } }>('/:id', async (request, reply) => {
    const { id } = request.params;
    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    return workflow;
  });

  // Create a new workflow
  app.post<{ Body: WorkflowCreateInput & { groupId?: string; folderId?: string } }>('/', async (request, reply) => {
    const { name, description, nodes, connections, settings, tags, groupId, folderId } = request.body;
    const userId = (request as { user?: { id: string } }).user?.id;

    // Generate Python code from workflow definition
    const workflowNodes = (nodes || []) as unknown[];
    const workflowConnections = (connections || []) as unknown[];

    const pythonCode = generatePythonCode({
      id: 'new',
      name: name || 'Untitled Workflow',
      description: description || undefined,
      nodes: workflowNodes,
      connections: workflowConnections,
    } as Parameters<typeof generatePythonCode>[0]);

    const workflow = await prisma.workflow.create({
      data: {
        name,
        description,
        nodes: (nodes || []) as unknown as Prisma.InputJsonValue,
        connections: (connections || []) as unknown as Prisma.InputJsonValue,
        settings: (settings || {}) as unknown as Prisma.InputJsonValue,
        tags: tags || [],
        createdById: userId,
        groupId,
        folderId,
        // Store generated Python code
        pythonWorkflow: pythonCode.pythonWorkflow,
        pythonActivities: pythonCode.pythonActivities,
        pythonRequirements: pythonCode.pythonRequirements,
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
        folder: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return reply.status(201).send(workflow);
  });

  // Update a workflow
  app.put<{ Params: { id: string }; Body: WorkflowUpdateInput }>(
    '/:id',
    async (request, _reply) => {
      const { id } = request.params;
      const { name, description, nodes, connections, settings, active, tags } = request.body;

      // Get existing workflow to merge with updates
      const existing = await prisma.workflow.findUnique({ where: { id } });
      if (!existing) {
        throw new Error('Workflow not found');
      }

      // Regenerate Python code if nodes or connections changed
      let pythonCodeUpdate = {};
      if (nodes !== undefined || connections !== undefined || name !== undefined) {
        const workflowNodes = (nodes ?? existing.nodes) as unknown[];
        const workflowConnections = (connections ?? existing.connections) as unknown[];

        const pythonCode = generatePythonCode({
          id,
          name: name ?? existing.name,
          description: (description ?? existing.description) || undefined,
          nodes: workflowNodes,
          connections: workflowConnections,
        } as Parameters<typeof generatePythonCode>[0]);

        pythonCodeUpdate = {
          pythonWorkflow: pythonCode.pythonWorkflow,
          pythonActivities: pythonCode.pythonActivities,
          pythonRequirements: pythonCode.pythonRequirements,
        };
      }

      const workflow = await prisma.workflow.update({
        where: { id },
        data: {
          // Increment version on every save
          version: { increment: 1 },
          ...(name !== undefined && { name }),
          ...(description !== undefined && { description }),
          ...(nodes !== undefined && { nodes: nodes as unknown as Prisma.InputJsonValue }),
          ...(connections !== undefined && { connections: connections as unknown as Prisma.InputJsonValue }),
          ...(settings !== undefined && { settings: settings as unknown as Prisma.InputJsonValue }),
          ...(active !== undefined && { active }),
          ...(tags !== undefined && { tags }),
          ...pythonCodeUpdate,
        },
      });

      // Commit to GitHub if configured
      if (workflow.githubRepo && workflow.localPath) {
        const gitResult = await commitWorkflowToGitHub(workflow);
        if (!gitResult.success) {
          console.error('GitHub commit failed:', gitResult.error);
          // Don't fail the save, just log the error
        }
      }

      return workflow;
    },
  );

  // Delete a workflow
  app.delete<{ Params: { id: string } }>('/:id', async (request, reply) => {
    const { id } = request.params;

    await prisma.workflow.delete({
      where: { id },
    });

    return reply.status(204).send();
  });

  // Promote workflow to next environment
  // DV -> UT -> LT -> PD
  // Only admins can promote to PD
  app.post<{
    Params: { id: string };
    Body: { targetEnvironment: 'UT' | 'LT' | 'PD' };
  }>('/:id/promote', async (request, reply) => {
    const { id } = request.params;
    const { targetEnvironment } = request.body;
    const user = (request as { user?: { id: string; isAdmin?: boolean } }).user;

    // Get current workflow
    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Define valid promotion paths
    const promotionOrder = ['DV', 'UT', 'LT', 'PD'] as const;
    const currentIndex = promotionOrder.indexOf(workflow.environment);
    const targetIndex = promotionOrder.indexOf(targetEnvironment);

    // Validate promotion is sequential (can only promote to next stage)
    if (targetIndex !== currentIndex + 1) {
      return reply.status(400).send({
        error: `Invalid promotion. Can only promote from ${workflow.environment} to ${promotionOrder[currentIndex + 1] || 'nowhere (already at PD)'}`
      });
    }

    // Direct usage of this endpoint is now restricted to Admins (Force Promote)
    // Regular users must use the /promotions/request flow.
    if (!user?.isAdmin) {
      return reply.status(403).send({
        error: 'Direct promotion is restricted to administrators. Please use the Promotion Request workflow.'
      });
    }

    // Perform the promotion
    const updatedWorkflow = await prisma.workflow.update({
      where: { id },
      data: {
        environment: targetEnvironment,
        promotedAt: new Date(),
        promotedById: user?.id,
      },
      include: {
        group: {
          select: { id: true, name: true },
        },
        createdBy: {
          select: { id: true, email: true, name: true },
        },
      },
    });

    return updatedWorkflow;
  });

  // Demote workflow to previous environment (admin only)
  app.post<{
    Params: { id: string };
    Body: { targetEnvironment: 'DV' | 'UT' | 'LT' };
  }>('/:id/demote', async (request, reply) => {
    const { id } = request.params;
    const { targetEnvironment } = request.body;
    const user = (request as { user?: { id: string; isAdmin?: boolean } }).user;

    // Only admins can demote
    if (!user?.isAdmin) {
      return reply.status(403).send({
        error: 'Only administrators can demote workflows'
      });
    }

    // Get current workflow
    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Define valid demotion paths
    const promotionOrder = ['DV', 'UT', 'LT', 'PD'] as const;
    const currentIndex = promotionOrder.indexOf(workflow.environment);
    const targetIndex = promotionOrder.indexOf(targetEnvironment);

    // Validate demotion is to a lower stage
    if (targetIndex >= currentIndex) {
      return reply.status(400).send({
        error: `Invalid demotion. Target environment must be lower than current (${workflow.environment})`
      });
    }

    // Perform the demotion
    const updatedWorkflow = await prisma.workflow.update({
      where: { id },
      data: {
        environment: targetEnvironment,
        promotedAt: new Date(),
        promotedById: user?.id,
      },
      include: {
        group: {
          select: { id: true, name: true },
        },
        createdBy: {
          select: { id: true, email: true, name: true },
        },
      },
    });

    return updatedWorkflow;
  });

  // Export workflow as Python Temporal application
  app.get<{
    Params: { id: string };
    Querystring: { format?: 'json' | 'tar' };
  }>('/:id/export/python', async (request, reply) => {
    const { id } = request.params;
    const { format = 'tar' } = request.query;

    const workflow = await prisma.workflow.findUnique({
      where: { id },
    });

    if (!workflow) {
      return reply.status(404).send({ error: 'Workflow not found' });
    }

    // Generate Python files
    const files = generatePythonExport({
      id: workflow.id,
      name: workflow.name,
      description: workflow.description || undefined,
      nodes: workflow.nodes as unknown[],
      connections: workflow.connections as unknown[],
    } as Parameters<typeof generatePythonExport>[0]);

    // Create directory name from workflow name, environment, and version
    const safeName = workflow.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '') || 'workflow';
    const dirName = `${safeName}-${workflow.environment.toLowerCase()}-v${workflow.version}`;

    if (format === 'tar') {
      // Create a temporary directory with the workflow files
      const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'twiddle-export-'));
      const workflowDir = path.join(tempDir, dirName);

      try {
        // Create the workflow directory
        fs.mkdirSync(workflowDir, { recursive: true });

        // Write all files to the directory
        for (const [filename, content] of Object.entries(files)) {
          fs.writeFileSync(path.join(workflowDir, filename), content, 'utf-8');
        }

        // Also write the workflow definition for re-import
        const definition = {
          workflowId: workflow.id,
          workflowName: workflow.name,
          workflowDescription: workflow.description,
          version: workflow.version,
          environment: workflow.environment,
          exportedAt: new Date().toISOString(),
          definition: {
            nodes: workflow.nodes,
            connections: workflow.connections,
            settings: workflow.settings,
            tags: workflow.tags,
          },
        };
        fs.writeFileSync(
          path.join(workflowDir, 'twiddle-workflow.json'),
          JSON.stringify(definition, null, 2),
          'utf-8'
        );

        // Create the tarball
        const tarballPath = path.join(tempDir, `${dirName}.tar.gz`);
        await createTar(
          {
            gzip: true,
            file: tarballPath,
            cwd: tempDir,
          },
          [dirName]
        );

        // Read the tarball and send it
        const tarballBuffer = fs.readFileSync(tarballPath);

        // Clean up temp directory
        fs.rmSync(tempDir, { recursive: true, force: true });

        // Send the tarball
        return reply
          .header('Content-Type', 'application/gzip')
          .header('Content-Disposition', `attachment; filename="${dirName}.tar.gz"`)
          .send(tarballBuffer);

      } catch (err) {
        // Clean up on error
        try {
          fs.rmSync(tempDir, { recursive: true, force: true });
        } catch {
          // Ignore cleanup errors
        }
        throw err;
      }
    }

    // Return as JSON with file contents and workflow definition for re-import
    return {
      workflowId: workflow.id,
      workflowName: workflow.name,
      workflowDescription: workflow.description,
      version: workflow.version,
      environment: workflow.environment,
      exportedAt: new Date().toISOString(),
      directoryName: dirName,
      // Include workflow definition for import
      definition: {
        nodes: workflow.nodes,
        connections: workflow.connections,
        settings: workflow.settings,
        tags: workflow.tags,
      },
      files,
    };
  });

  // Import workflow from exported JSON
  app.post<{
    Body: {
      workflowName?: string;
      workflowDescription?: string;
      definition: {
        nodes: unknown[];
        connections: unknown[];
        settings?: unknown;
        tags?: string[];
      };
      groupId?: string;
    };
  }>('/import', async (request, reply) => {
    const { workflowName, workflowDescription, definition, groupId } = request.body;
    const userId = (request as { user?: { id: string } }).user?.id;

    if (!definition || !definition.nodes) {
      return reply.status(400).send({ error: 'Invalid import data: missing definition.nodes' });
    }

    const name = workflowName || 'Imported Workflow';
    const nodes = definition.nodes || [];
    const connections = definition.connections || [];

    // Generate Python code from imported workflow
    const pythonCode = generatePythonCode({
      id: 'imported',
      name,
      description: workflowDescription || undefined,
      nodes: nodes as unknown[],
      connections: connections as unknown[],
    } as Parameters<typeof generatePythonCode>[0]);

    const workflow = await prisma.workflow.create({
      data: {
        name,
        description: workflowDescription,
        nodes: nodes as unknown as Prisma.InputJsonValue,
        connections: connections as unknown as Prisma.InputJsonValue,
        settings: (definition.settings || {}) as unknown as Prisma.InputJsonValue,
        tags: definition.tags || [],
        createdById: userId,
        groupId,
        pythonWorkflow: pythonCode.pythonWorkflow,
        pythonActivities: pythonCode.pythonActivities,
        pythonRequirements: pythonCode.pythonRequirements,
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return reply.status(201).send(workflow);
  });
};
