"""
Twiddle SDK - Airflow DAG Generator

Generates Apache Airflow DAG files from Twiddle DSL code.
"""

from typing import Any, Dict, List


def generate_dag_file(workflow_meta: Dict[str, Any], activities_meta: List[Dict[str, Any]]) -> str:
    """Generate dag.py content."""
    name = workflow_meta.get("name", "twiddle_workflow")
    description = workflow_meta.get("description", "Generated from Twiddle")
    dag_id = workflow_meta.get("dag_id", name.lower().replace(" ", "_"))

    # Generate task imports
    task_imports = []
    task_definitions = []
    task_dependencies = []
    prev_task = None

    for i, activity in enumerate(activities_meta):
        func_name = activity.get("function_name", f"task_{i}")
        task_id = func_name
        task_imports.append(f"from tasks.{func_name} import {func_name}")
        
        task_def = f'''
    {task_id} = PythonOperator(
        task_id="{task_id}",
        python_callable={func_name},
        op_kwargs={{"input_data": "{{}}" }},  # Pass input via XCom or params
    )'''
        task_definitions.append(task_def)
        
        if prev_task:
            task_dependencies.append(f"    {prev_task} >> {task_id}")
        prev_task = task_id

    imports_str = "\n".join(task_imports)
    tasks_str = "\n".join(task_definitions)
    deps_str = "\n".join(task_dependencies) if task_dependencies else "    pass  # No dependencies defined"

    return f'''"""
{name}

{description}

Auto-generated Airflow DAG from Twiddle DSL.
"""
from datetime import datetime, timedelta

from airflow import DAG
from airflow.operators.python import PythonOperator

# Import task functions
{imports_str}


# Default arguments for the DAG
default_args = {{
    "owner": "twiddle",
    "depends_on_past": False,
    "email_on_failure": False,
    "email_on_retry": False,
    "retries": 1,
    "retry_delay": timedelta(minutes=5),
}}

# DAG definition
with DAG(
    dag_id="{dag_id}",
    default_args=default_args,
    description="{description}",
    schedule_interval=None,  # Manual trigger only
    start_date=datetime(2024, 1, 1),
    catchup=False,
    tags=["twiddle", "generated"],
) as dag:
    
    # Task definitions
{tasks_str}

    # Task dependencies
{deps_str}
'''


def generate_task_file(activity_meta: Dict[str, Any]) -> str:
    """Generate a task implementation file."""
    func_name = activity_meta.get("function_name", "unknown_task")
    name = activity_meta.get("name", func_name)
    description = activity_meta.get("description", "")
    parameters = activity_meta.get("parameters", [])

    # Generate parameter docstring
    param_docs = []
    for param in parameters:
        param_name = param.get("name", "param")
        param_desc = param.get("description", "")
        param_docs.append(f"        {param_name}: {param_desc}")
    
    params_docstring = "\n".join(param_docs) if param_docs else "        None"

    return f'''"""
{name}

{description}
"""
import logging
from typing import Any, Dict, Optional

logger = logging.getLogger(__name__)


def {func_name}(input_data: Optional[Dict[str, Any]] = None, **kwargs) -> Dict[str, Any]:
    """
    {name}
    
    {description}
    
    Args:
{params_docstring}
        input_data: Input data from previous task (via XCom)
        **kwargs: Airflow context variables
    
    Returns:
        Dict containing the task output
    """
    # Get Airflow task instance for XCom
    ti = kwargs.get("ti")
    
    # Get input from XCom if available
    if ti and not input_data:
        input_data = ti.xcom_pull(task_ids=None, key="return_value") or {{}}
    
    input_data = input_data or {{}}
    
    logger.info(f"Executing {name}")
    logger.debug(f"Input data: {{input_data}}")
    
    # TODO: Implement task logic here
    result = {{
        **input_data,
        "{func_name}_completed": True,
    }}
    
    logger.info(f"Task {name} completed")
    return result
'''


def generate_requirements() -> str:
    """Generate requirements.txt content for Airflow."""
    return '''# Twiddle DSL
twiddle-dsl>=1.0.0

# Apache Airflow
apache-airflow>=2.8.0

# Utilities
python-dotenv>=1.0.0
requests>=2.31.0
'''


def generate_readme(workflow_meta: Dict[str, Any]) -> str:
    """Generate README.md content for Airflow project."""
    name = workflow_meta.get("name", "Workflow")
    dag_id = workflow_meta.get("dag_id", name.lower().replace(" ", "_"))
    description = workflow_meta.get("description", "A DAG generated by Twiddle SDK.")

    return f'''# {name}

{description}

## Quick Start

### Option 1: Copy to Airflow DAGs folder

```bash
# Copy DAG and tasks to your Airflow DAGs folder
cp -r . $AIRFLOW_HOME/dags/{dag_id}/
```

### Option 2: Use with Docker Compose

```bash
# Copy to the Twiddle Docker Airflow DAGs folder
cp -r . ../docker/airflow/dags/{dag_id}/
```

## Files

| File | Description |
|------|-------------|
| `dag.py` | Main DAG definition |
| `tasks/` | Task implementations |
| `requirements.txt` | Python dependencies |

## DAG Info

- **DAG ID**: `{dag_id}`
- **Schedule**: Manual trigger (no schedule)
- **Tags**: `twiddle`, `generated`

## Airflow UI

Access at: http://localhost:8080

Default credentials:
- Username: `airflow`
- Password: `airflow`

## Triggering the DAG

1. Open Airflow UI
2. Find DAG: `{dag_id}`
3. Enable the DAG (toggle on)
4. Click "Trigger DAG" button
'''


def generate_init_file() -> str:
    """Generate __init__.py for tasks package."""
    return '''"""
Task implementations for the Twiddle DAG.
"""
'''


def generate_all_airflow_files(
    workflow_meta: Dict[str, Any],
    activities_meta: List[Dict[str, Any]],
) -> Dict[str, str]:
    """
    Generate all files for an Airflow DAG.

    Args:
        workflow_meta: Workflow metadata
        activities_meta: List of activity metadata

    Returns:
        Dict mapping filename to content
    """
    files = {
        "dag.py": generate_dag_file(workflow_meta, activities_meta),
        "requirements.txt": generate_requirements(),
        "README.md": generate_readme(workflow_meta),
        "tasks/__init__.py": generate_init_file(),
    }

    # Generate individual task files
    for activity in activities_meta:
        func_name = activity.get("function_name", "unknown")
        files[f"tasks/{func_name}.py"] = generate_task_file(activity)

    return files
